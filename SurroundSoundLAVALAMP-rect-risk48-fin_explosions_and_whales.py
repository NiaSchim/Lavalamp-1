#-------------------------------------------------------------------------------
# Name:        LavalampParticles.py
# Purpose: pretty visualizer
#
# Author:      The Schim
#
# Created:     16/03/2023
# Copyright:   (c) The Schim 2023
# Licence:     CC0
#-------------------------------------------------------------------------------
import pygame
import random
import math
from colorsys import hsv_to_rgb, rgb_to_hsv
import uuid

# Constants
WIDTH, HEIGHT = 800, 600
BG_COLOR = (0, 0, 0)
FPS = 60
MIN_RADIUS = 33.3
MAX_RADIUS = 99.9
SPLIT_PROB = 0.29
DEPTH = 700
cooldown = random.randint(314, 6400)
INITIAL_GLOBS = 25
MAX_NUMBER_GLOBS = 115
SPEED_DIVISOR = 2.0+(1/math.pi)
AGE_FACTOR = 0.1
TRANSFER = 0.00075

from scipy.signal import firwin, lfilter
import numpy as np
import simpleaudio as sa
import scipy.signal
import threading
import time
import sounddevice as sd
import scipy.optimize as opt

# Define audio constants
SAMPLE_RATE = int(44100//100)
BIT_DEPTH = -16
NUM_CHANNELS = 2
AUDIO_BUFFER_SIZE = round(1024*2)
NUM_CHANNELS = 2  # mono audio with psuedo surround
AMPLITUDE = 5 # maximum amplitude of the audio signal
PENTATONIC_SCALE = [2, 4, 6, 9, 11]  # pentatonic scale intervals in semitones
OCTAVES = 8  # number of octaves to span with the pentatonic scale
BASE_FREQ = 466.16
SEMITONE_RATIO =  1.061803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748475408807538689175212663386222353693179318006076672635443338908659593958290563832266131992829026788067520876689250171169620703222104321626954862629631361443814975870122034080588795445474924618569536486444924104432077134494704956584678850987433944221254487706647809158846074998871240076521705751797883416625624940758906970400028121042762177111777805315317141011704666599146697987317613560067087480710131795236894275219484353056783002287856997829778347845878228911097625003026961561700250464338243776486102838312683303724292675263116533924731671112115881863851331620384005222165791286675294654906811317159934323597349498509040947621322298101726107059611645629909816290555208524790352406020172799747175342777592778625619432082750513121815628551222480939471234145170223735805772786160086883829523045926478780178899219902707769038953219681986151437803149974110692608867429622675756052317277752035361393621076738937645560606059216589466759551900400555908950229530942312482355212212415444006470340565734797663972394949946584578873039623090375033993856210242369025138680414577995698122445747178034173126453220416397232134044449487302315417676893752103068737880344170093954409627955898678723209512426893557309704509595684401755519881921802064052905518934947592600734852282101088194644544222318891319294689622002301443770269923007803085261180754519288770502109684249362713592518760777884665836150238913493333122310533923213624319263728910670503399282265263556209029798642472759772565508615487543574826471814145127000602389016207773224499435308899909501680328112194320481964387675863314798571911397815397807476150772211750826945863932045652098969855567814106968372884058746103378105444390943683583581381131168993855576975484149144534150912954070050194775486163075422641729394680367319805861833918328599130396072014455950449779212076124785645916160837059498786006970189409886400764436170933417270919143365013715766011480381430626238051432117348151005590134561011800790506381421527093085880928757034505078081454588199063361298279814117453392731208092897279222132980642946878242748740174505540677875708323731097591511776297844328474790817651809778726841611763250386121129143683437670235037111633072586988325871033632223810980901211019899176841491751233134015273384383723450093478604979294599158220125810459823092552872124137043614910205471855496118087642657651106054588147560443178479858453973128630162544876114852021706440411166076695059775783257039511087823082710647893902111569103927683845386333321565829659773103436032322545743637204124406408882673758433953679593123221343732099574988946995656473600729599983912881031974263125179714143201231127955189477817269141589117799195648125580018455065632952859859100090862180297756378925999164994642819302229355234667475932695165421402109136301819472270789012208728736170734864999815625547281137347987165695274890081443840532748378137824669174442296349147081570073525457070897726754693438226195468615331209533579238014609273510210119190218360675097308957528957746814229543394385493155339630380729169175846101460995055064803679304147236572039860073550760902317312501613204843583648177048481810991602442523271672190189334596378608787528701739359303013359011237102391712659047026349402830766876743638651327106280323174069317334482343564531850581353108549733350759966778712449058363675413289086240632456395357212524261170278028656043234942837301725574405837278267996031739364013287627701243679831144643694767053127249241047167001382478312865650649343418039004101780533950587724586655755229391582397084177298337282311525692609299594224000056062667867435792397245408481765197343626526894488855272027477874733598353672776140759171205132693448375299164998093602461784426757277679001919190703805220461232482391326104327191684512306023627893545432461769975753689041763650254785138246314658336383376023577899267298863216185839590363998183845827644912459809370430555596137973432613483049494968681089535696348281781288625364608420339465381944194571426668237183949183237090857485026656803989744066210536030640026081711266599541993687316094572288810920778822772036366844815325617284117690979266665522384688311371852991921631905201568631222820715599876468423552059285371757807656050367731309751912239738872246825805715974457404842987807352215984266766257807706201943040054255015831250301753409411719101929890384472503329880245014367968441694795954530459103138116218704567997866366174605957000344597011352518134600656553520347888117414994127482641521355677639403907103870881823380680335003804680017480822059109684420264464021877053401003180288166441530913939481564031928227854824145105031888251899700748622879421558957428202166570621880905780880503246769912972872103870736974064356674589202586565739785608595665341070359978320446336346485489497663885351045527298242290699848853696828046459745762651434359050938321243743333870516657149005907105670248879858043718151261004403814880407252440616429022478227152724112085065788838712493635106806365166743222327767755797399270376231914704732395512060705503992088442603708790843334261838413597078164829553714321961189503797714630007555975379570355227144931913217255644012830918050450089921870512118606933573153895935079030073672702331416532042340155374144268715405511647961143323024854404094069114561398730260395182816803448252543267385759005604320245372719291248645813334416985299391357478698957986439498023047116967157362283912018127312916589952759919220318372356827279385637331265479985912463275030060592567454979435088119295056854932593553187291418011364121874707526281068698301357605247194455932195535961045283031488391176930119658583431442489489856558425083410942950277197583352244291257364938075417113739243760143506829878493271299751228688196049835775158771780410697131966753477194792263651901633977128473907933611119140899830560336106098717178305543540356089529290818464143713929437813560482038947912574507707557510300242072662900180904229342494259060666141332287226980690145994511995478016399151412612525728280664331261657469388195106442167387180001100421848302580916543383749236411838885646851431500637319042951481469424314608952547072037405566913069220990804819452975110650464281054177552590951871318883591476599604131796020941530858553323877253802327276329773721431279682167162344211832018028814127474431688472184593927814354740999990722332030592629766112383279833169882539312620065037028844782866694044730794710476125586583752986236250999823233597155072338383324408152577819336426263043302658958170800451278873115935587747217256494700051636672577153920984095032745112153687300912199629522765913163709396860727134269262315475330437993316581107369643142171979434056391551210810813626268885697480680601169189417502722987415869917914534994624441940121978586013736608286907223651477139126874209665137875620591854328888341742920901563133283193575622089713765630978501563154982456445865424792935722828750608481453351352181729587932991171003247622205219464510536245051298843087134443950724426735146286179918323364598369637632722575691597239543830520866474742381511079273494836952396479268993698324917999502789500060459661313463363024949951480805329017902975182515875049007435187983511836032722772601717404535571658855578297291061958193517105548257930709100576358699019297217995168731175563144485648100220014254540554292734588371160209947945720823780436871894480563689182580244499631878342027491015335791072733625328906933474123802222011626277119308544850295419132004009998655666517756640953656197897818380451030356510131589458902871861086905893947136801484570018366495647203294334374298946427412551435905843484091954870152361403173913903616440198455051049121169792001201999605069949664030350863692903941007019450532016234872763232732449439630480890554251379723314751852070910250636859816795304818100739424531700238804759834323450414258431406361272109602282423378228090279765960777108493915174887316877713522390091171173509186006546200990249758527792542781659703834950580106261553336910937846597710529750223173074121778344189411845965861029801877874274456386696612772450384586052641510304089825777754474115332076407588167751497553804711629667771005876646159549677692705496239398570925507027406997814084312496536307186653371806058742242598165307052573834541577054292162998114917508611311765773172095615656478695474489271320608063545779462414531066983742113798168963823533304477883169339728728918103664083269856988254438516675862289930696434684897514840879039647604203610206021717394470263487633654393195229077383616738981178124248365578105034169451563626043003665743108476654877780128577923645418522447236171374229255841593135612866371670328072171553392646325730673063910854108868085742838588280602303341408550390973538726134511962926415995212789311354431460152730902553827104325966226743903745563612286139078319433570590038148700898661315398195857442330441970856696722293142730741384882788975588860799738704470203166834856941990965480298249319817657926829855629723010682777235162740783807431877827318211919695280051608791572128826337968231272562870001500182929757729993579094919640763442861575713544427898383040454702710194580042582021202344580630345033658147218549203679989972935353919681213319516537974539911149424445183033858841290401817818821376006659284941367754317451605409387110368715211640405821934471204482775960541694864539878326269548013915019038995931306703186616706637196402569286713887146631189192685682691995276457997718278759460961617218868109454651578869122410609814197268619255478789926315359472922825080542516906814010781796021885330762305563816316401922454503257656739259976517530801427160714308718862859836037465057134204670083432754230277047793311183666903232885306873879907135900740304907459889513647687608678443238248218930617570319563803230819719363567274196438726258706154330729637038127515170406005057594882723856345156390526577104264594760405569509598408889037620799566388017861855915944111725092313279771138032943765475090165169496509916073833937715833230245701948347400070437618671998483401631826008462619656284649118225688857521346375490254180833821383522245258726789379505375915603579454698509102256225455003017571049469833483545323835260787092219304581782306012370753280678368541306584636788866433486249368010198782799630670259543265137806007386392908564830874157618741897345848450141889765293411013722158643559915527113623322003526677859159890231446163321026519665907632061524383747619049531582968836265042094840105654589130629827717249809641959472340465110419821347689354018038256954956286039244264159867485982280060353862839166201252826607493306196584965199979419393226017235710733642537083033011433624985753635970424446475998999950855041354977558585934576590926533307252775416758431466936767806170350120038448748838233760344077515947781221883070900087386627362091660799050226989270321899760379509890591085910392967345614610700304581921273892599269610621167643642438350141020408632149917815297968152237983224273753657008553469979655413859050326836160222788475547062698439108852103020768604706804556846560491686498860616222952323907098092629302337956482179981632645827888877674520846371971063478923106675469355047615197781699025881840407927510901824482787052505976983753514306224450902202382439823125505841623207188319300693606464682096595006549290109716186526367216107417136183776673327975626854801245657682790317603946555394523143387567730349791578588591011663748455675847952713918608782540104233329857442747118969610485126401975043599092076621558998660736837623188358845081292950114665354828171448464056865246540907815471619625784469575262569455165601519164029217988548909373280314651922247590030965715490505361043776868772619159528449204647868973473708598413845131621192972012634240773694545981865029659233534512568454974541129819735876670728601616056204230636066130281496773445797737750557564665475256322648177116997857087122831543104569123262503497681152452174497396136748822046480519688754341969511933120450216051429384844754523821270143830957855813619678302310685080845876952059053294683384904712099162556365034003439670828933698367423001575117385151269123066172276414421607512917341874714315093241924914160969998672815823859257359823894849274919646152272273338746312138436262116379467062032630225055489580573083750461299231136299173069489407342588319483999274163950984439634057635284717562762192786522539608720131080486406534396168875452534263098969517619019770963192258709342165955974471750157538376741522280570650280683143356524917199733358403064153550759115974264366482846628136802174505909705894602744292632222215459450758046571206068639904308236939693208237490767561190171561305424813311715242568478463363770015204417916501168232575236160495749706390822443444510351219048819830276001766809850965245439007199098034993026860675523879685292194732393352370086650221407464554037222343481675749373144640928379006539196774010355861936181566836616864892395554961452826472894994160615803045867891461971728155451100056660542499691974102798740593276434953714525167694620698597880946950174730228414275718871940921209137994059430370504364838600434645227993302923901865922689874992113256560557840142335426058951056203690720289393159204404768359276364799600596404860761989159298194950878786027663459905404263770045900803279434720629825445256356479542992488198646136171314485773469953475577155491384239289401754034139973846169481293479242234609743019627523013828607224496380953838401526567819764507588547855155492345234781646033062938842009950803260140918302574385770671025227243666905988908545015570754230316665924723528924702588624794887546252765727285151112878270673454310244515233456542284311039679528296250193698939983473961763988095735415260145372964681473821843600521099472119416591494716705203792255209633645848468041447780302164728623999264048363508773747824501638200895240322534379925790129265640155537754091751704419627285039126695956664877242967660367303453668734049079141886945214715827908157233969124039985869390855173079801955546128513408912061084012213617070570430060569246855916468834773320856891412679428448041384682813256929148160109786272696866867373917118931462269134894580427789899608144709524762905019260311649206867743318661546966896601822663578788750608856243562678932797354633904182108774638039216244772025672699596391824687788455497179038515839204748319903127622437066235092518775434140107112335865907748122063763459019884225472727655290504399502524440391136582670813300580588209460310208261341369127572936992893029961730892843670315238589753987388936807441526373794240506448764171768613552343269865728970463069180174277972173889859443284852057257588337563820150546720651674252681894851673328046307647813293132602893229366045210213189812987661526244487486693890406178469916665417485084597970146178215845014919572109825089234517474512254327386819725864944588083771398685065984085457731654169174067052111949166286337732263753475666370022120327524389997736006074042702972203634778048298834855189525079474605519940340110771169725644261005092059843362535847069597185762616776630211747878341975644501838041029203240408826617344339090263522350506828582854432839618480925376130820115626869907999117084755586982150310073563240421988569584200682439926953784403202222374628147659230605547476936830576549677690471159625502474507809624837449908025613750915622359081010534493941774294277091445166668700415228544638076615351141556487854936011387473103828773313388391709646174829063156788065182761765798535021665998607464012674884121130098549938337106031962506702797524310119377335548537011694674858888363080333287739571656275340367272180705622562326374148833499289970258977299224036941750743427314194157432466794578586039894075097356363688815672159676354380665593938934382075984061216064317664421902677773799145579945031468708716266226524133590569928494006372744908821635242948022566330458553636337251762049074624062938962390622030424872688432377631733574205753997574373508409657792180880089420590662572782307692788656445563758012667280952527379828030076636976928164844651277473822397061738567507146692748220374881122563994075227626464994658463674019559973702838393119884822335539964978333165008467491254522956512409390963784095416901234675375280139080830863022653352387069273071984654649454979101134287154636695543437462154391886526085366974366530588562164411648068912837357794341530609478457270987037976921346205969538843826760827659181773627669918727803754219954172428335791064520613736884708545165822193158645377018313401818827251099922917614711860529176551422881123566217241692680620648845317615164272953585798375412375876100415475805595730122459276711895277333823356043374201321392804317053379463646428351993014576706491847707768959885421647973371769625943938648074893633201098893643528324494132569317438323509258286421276209473432879984387198291625035886368857440896091619767553023636147840186271827708891360398933077293060296717760258418030133475474406093218222662077059842476082637941388598601935208959821941885723823714271930349354518240112671046073097412681279072726438685681544729144826761389945092064098792647692574698812334642995267308237405720406143748700867048612599590178424976845844736824827947824753176338174814799571031203396345226743415123722322454626546328353564246627786460839872179127843089641636422237152822199860850600158245169478318926060165827491142774933502865503727691068107557826463340399219222602208590967841860013859653877265826244657597694069240541804444738471607901449743018055889337623761296918229234768453759556468421122698731637506249971182291485689604472527760093934343558339195165132985623645893149101860849683480338090932736261062054795970421298669883573560404347128399801249802209466851093490407878450102117684276345079137687609746900665759683043519266676563960922648845670212850744821184836102907689196493402300641753173483914758916672023069245347107627719792524997328576890388680141780313799483651089527220946591304506656658258539174690486872649902546765966599164547365134259755577397348506528439977384490513905829430130008366961455669748537793407881277215791487210719258869089277878732982982214574233273265987982756950898845306240223036486347722967056524127035887830281940074980575439016285786745531327197652607107643153112391526077219362144346096089758726934223674331613718574577608117751518069662104795585140130069701845007026290479492570837120175279378554957627391245587148332010170361840521636818017341425089806160634676330850504184585816629334093479199103685913053789482158651701181210113330006695775232786685518078256752836149494920745837336845813691407977595925267273966423478746614399819648081036705066005238269165055144634711116867428177319502560642951637959659475644987891461446925936629309364804816174059808214254340525211371332408113913579971622858101419103410460569290782498956214560041045692221416830893236662517618696271719453854998551484275173369241202680159928083201458300754484742331264387808478085056104304909999364345905195187494843696772757473359670883349609157447435750398602016397666114276536952670441155200193914842934601015129531174458876483070371677396154265591399083037577663021309908712719887069032930470124105861506399852998141757804303480803588203202011047607004755710169423412034108915643947825303164593730437558194686752534953230130276782353560116641311177996099793662043449569683547930754311327558643189731515171064432189249793277801264964764475467078165807406131259375271847408816115479818307816751047809291413954564631160581269051753953556915775580410671981231638405277556052272223764711883233223099585068971018717504781906533494858423259762256575841898529144717833517322602985786292943465056366932162627673816245957417932698892327220666636081992490988831468529940991386734446049670842442978243630232938910355965601739942201988690257245471401633009612146187208365108688185334060622017099515827070442337042180176696349133695996064322005328873494893135966030424380804565944743335678316727037296363675942169993795216709569239605768464124347542886216245149157793040476753348053033153307521541526385710525422090937728732169921993755078088729411025976039372079494630773816321627677758231545511712133606496443134498613014698318686111929868996577503784519451854724162206976130886307000710449638898858341033555502859580220113658542705557765562668931284762149536288307592916507067735066925352644695336056301100688585609305533142306464911577431203418266408784648989833436453569414451359565299946353194873235833654149912091860340699657865139372140627836385084775887199350057479097575575821175405351435523866639331618523705204967991251182676180080717649555661886440043165185901961567355270606851436442192137316100204985388311981864969315190493719216273102798831337759268776002675993022444055363142019164277411901370175415170402452994379515292362166695619231382936999237019398531726989373859914221290389848610849267471382592106802650550676862778123345733959989844690818355080097898838050307572662908675028309257586145638783656294981053573592917496461623137707802996548502550264310977934737337524379483252699651218500997055530858400309861246730432929767608197353492136895008495286646640838728286016708683549765123021169308056436872386411643645448955160189710984522491878379890966570195078344359051912278712755757733414151965739899834250985394949988141243867834464873827376170542306270476547318264631092291393359618691179772831791867789266428054498091940593562998414835665844886741681797338164265740108940859491300072021588718078252254566398621813980490305216416264740583335375040007401944822542799937106484915540517805980677612154774199779863715955202827504416259521370231996415590408422945370845053182339069574228180267420934592943172176664705528067554152692935177725126373997210446455205841575750464849453827350764901238368245042240627692293459944117496893475532632823427014968216980654553172552398001772054307127018595684369569896821609274381477524861268071826303308720453858655587689811222175453630040489748768999958305726483427590138858476503981930580029789904414320737977684158031959270878986203686850567428253092616139905181459089956386311375579715072615294130317445492402147964746006967031278643019018820326716298212114252367320903055760369513934774922721962527524190979265435827058619143826236169596554570620436214536914822593105671368762112020418219967004586305486471435319876530196330777690285679543242031748695423978897102466863258735101760481858925973866441814562327799457300954367413841317476805534437990136455326858247674930722202900176242045728990633288539907851099363098353777693682699124705280123778232411442696591393016391555798526705894127926299499436463694470124952235021746832175888475755348746313185164231799127100671136990144220424064070263374666063079096224489100129522953604036686289554466354237554841828524675610324706812483024928725253862445798579719593
FRAME_INTERVAL = (((FPS/(math.pi+1)**1.835/(1.00756))*((math.pi*2.5)))/2.658)/(math.pi*.938)
FRAME_INTERVAL2 =  FPS/math.pi
BUFFER_OVERLAP = AUDIO_BUFFER_SIZE
start = True
thread_running = True

# Add these lines at the beginning of the script
pygame.mixer.init()
pygame.mixer.set_num_channels(2)
# Define global variables
current_buffer = bytes()
current_buffer_lock = threading.Lock()

def generate_next_buffer(globs):
    VOLUME_SHRINK_FACTOR=1
    speed_of_sound_in_water = 197.4
    max_distance =DEPTH/3
    num_samples = int(FRAME_INTERVAL * SAMPLE_RATE)
    next_signal = np.zeros((num_samples,), dtype=np.float32)

    for glob in globs:
        distance = math.sqrt((glob.x - WIDTH / 2) ** 2 + (glob.y - HEIGHT / 2) ** 2 + (glob.z - DEPTH / 2) ** 2)
        if distance >= max_distance:
            amplitude = 0
        else:
            frequency = BASE_FREQ * SEMITONE_RATIO ** (PENTATONIC_SCALE[glob.num_globs % len(PENTATONIC_SCALE)] +
                                                      OCTAVES * math.log2(glob.radius) +
                                                      2 * math.log2(max_distance / (distance + max_distance)))

            # Parabolic function for amplitude
            amplitude = AMPLITUDE * (1 - 4 * (glob.z / DEPTH - 0.5) ** 2)

            # Multiply amplitude by the inverse of the frequency
            amplitude *= 1 / frequency

            if glob.vz > 0:
                if glob.z > DEPTH / 2:
                    doppler_shift = 1 + (speed_of_sound_in_water / 36) * (glob.vz / (DEPTH - glob.z))
                else:
                    doppler_shift = 1 - (speed_of_sound_in_water / 36) * (glob.vz / glob.z)
            else:
                if glob.z > DEPTH / 2:
                    doppler_shift = 1 - (speed_of_sound_in_water / 36) * (glob.vz / (DEPTH - glob.z))
                else:
                    doppler_shift = 1 + (speed_of_sound_in_water / 36) * (glob.vz / glob.z)

            amplitude *= doppler_shift

            # Generate triangle wave with the desired amplitude and Doppler shift
            triangle_wave = generate_triangle_wave(num_samples, frequency * doppler_shift, amplitude)
            next_signal += triangle_wave

    # Normalize the signal and convert to int8
    max_value = np.max(np.abs(next_signal))
    if max_value > 0:
        next_signal /= max_value
    else:
        next_signal = np.zeros((num_samples,), dtype=np.float32)

    # Multiply the signal by the volume shrink factor
    next_signal *= VOLUME_SHRINK_FACTOR

    fade_in_samples = round(SAMPLE_RATE * 1/8)  # ms fade in
    fade_out_samples = round(SAMPLE_RATE * 1/8)  # ms fade out
    next_signal = apply_fade(next_signal, fade_in_samples, fade_out_samples)

    next_signal_bytes = (next_signal * 127).astype(np.int8)

    # Ensure the buffer size is a multiple of bytes-per-sample and the number of channels
    buffer_size = len(next_signal_bytes)
    remainder = buffer_size % (NUM_CHANNELS * 1)  # 1 byte per sample for int8

    if remainder != 0:
        padding_size = NUM_CHANNELS * 1 - remainder
        next_signal_bytes = np.concatenate((next_signal_bytes, np.zeros(padding_size, dtype=np.int8)))

    return next_signal_bytes

def generate_next_buffer_thread(globs):
    global current_buffer
    next_buffer = generate_next_buffer(globs)
    current_buffer_lock.acquire()
    current_buffer = next_buffer
    current_buffer_lock.release()

def apply_fade(signal, fade_in_samples, fade_out_samples):
    fade_in = np.linspace(0, 1, fade_in_samples)
    signal[:fade_in_samples] = (signal[:fade_in_samples] * fade_in).astype(np.int8)

    if fade_out_samples > 0:
        fade_out = np.linspace(1, 0, fade_out_samples)
        signal[-fade_out_samples:] = (signal[-fade_out_samples:] * fade_out).astype(np.int8)

    return signal


def process_buffer(buffer, prev_buffer):
    if buffer.ndim > 1:
        buffer_mono = np.mean(buffer, axis=1).astype(np.int16)
    else:
        buffer_mono = buffer.astype(np.int16)

    buffer_mono_sq = buffer_mono * buffer_mono
    buffer_mono_sq = buffer_mono_sq.astype(np.int16)

    if prev_buffer is not None:
        crossfaded_data = crossfade(prev_buffer[-BUFFER_OVERLAP:], buffer_mono_sq[:BUFFER_OVERLAP], BUFFER_OVERLAP // 3)
        buffer_mono_sq[:crossfaded_data.shape[0]] = crossfaded_data

    return buffer_mono_sq


def play_buffer(channel_group, buffer, prev_buffer):
    buffer_mono_sq = process_buffer(buffer, prev_buffer)
    buffer_stereo_sq = np.repeat(buffer_mono_sq[:, np.newaxis], 2, axis=1)  # Duplicate mono signal into 2 identical channels
    sound = pygame.sndarray.make_sound(buffer_stereo_sq.astype(np.int16))
    channel_group.queue(sound)
    return buffer_mono_sq


def play_audio(globs, buffer1, buffer2, buffer3, thread_running, FRAME_INTERVAL):
    prev_buffer = np.zeros((AUDIO_BUFFER_SIZE * NUM_CHANNELS,), dtype=np.float64)

    while thread_running:
        channel_group1 = pygame.mixer.find_channel()
        channel_group2 = pygame.mixer.find_channel()
        channel_group3 = pygame.mixer.find_channel()

        prev_buffer = play_buffer(channel_group1, buffer1, prev_buffer)
        prev_buffer = play_buffer(channel_group2, buffer2, prev_buffer)
        prev_buffer = play_buffer(channel_group3, buffer3, prev_buffer)

        new_buffer = generate_next_buffer(globs)
        buffer1, buffer2, buffer3 = buffer2, buffer3, new_buffer
        pygame.time.wait(int(1000 * AUDIO_BUFFER_SIZE / SAMPLE_RATE))

def play_audio_second_interval(globs, buffer1, buffer2, buffer3, thread_running):
    play_audio(globs, buffer1, buffer2, buffer3, thread_running, FRAME_INTERVAL2)

def brachistochrone_curve(t, total_time):
    def f(cycloid_param):
        return cycloid_param - total_time * (1 - np.sin(cycloid_param)) / 2

    cycloid_param = opt.newton(f, 1)
    return (1 - np.cos(t * cycloid_param / total_time)) / 2

def crossfade(buffer1, buffer2, fade_duration):
    fade_duration = min(fade_duration, len(buffer1), len(buffer2))
    t = np.linspace(0, fade_duration, fade_duration)
    fade_out = 1 - brachistochrone_curve(t, fade_duration)
    fade_in = brachistochrone_curve(t, fade_duration)
    faded_buffer1 = buffer1[-fade_duration:] * fade_out
    faded_buffer2 = buffer2[:fade_duration] * fade_in
    return (faded_buffer1 + faded_buffer2).astype(np.int8)

def generate_pink_noise(num_samples, frequency, amplitude):
    """Generates pink noise using a simple approximation algorithm."""
    # Initialize the pink noise array with random values
    pink_noise = np.random.rand(num_samples)
    # Calculate the alpha value based on the frequency and amplitude
    alpha = amplitude * (math.sqrt(2)/10) * frequency
    # Apply a simple approximation filter to the pink noise
    for i in range(1, num_samples):
        pink_noise[i] = alpha * pink_noise[i] + (1 - alpha) * pink_noise[i-1]
    return amplitude * pink_noise

def generate_white_noise(num_samples, frequency, amplitude):
    """Generates white noise using NumPy's random module."""
    white_noise = np.random.randn(num_samples)
    return -amplitude * white_noise

#we're not really generating a triangle wave anymore, I'm just lazy, so I'm changing one function instead of 1 function and a billion name-calls
def generate_triangle_wave(num_samples, frequency, amplitude=1.0):
    """Generates a sine wave with the given frequency, amplitude, and sample rate."""
    t = np.linspace(0, num_samples / AUDIO_BUFFER_SIZE, num_samples, endpoint=False)
    triangle_wave = amplitude * np.sin(2 * np.pi * frequency * t)
    return triangle_wave

def generate_audio_signal(globs, VOLUME_SHRINK_FACTOR=0.85):
    VOLUME_SHRINK_FACTOR=1
    speed_of_sound_in_water = 197.4
    max_distance =DEPTH/3
    num_samples = int(FRAME_INTERVAL * SAMPLE_RATE)
    signal = np.zeros((num_samples,), dtype=np.float32)

    for glob in globs:
        distance = math.sqrt((glob.x - WIDTH / 2) ** 2 + (glob.y - HEIGHT / 2) ** 2 + (glob.z - DEPTH / 2) ** 2)
        if distance >= max_distance:
            amplitude = 0
        else:
            frequency = BASE_FREQ * SEMITONE_RATIO ** (PENTATONIC_SCALE[glob.num_globs % len(PENTATONIC_SCALE)] +
                                                      OCTAVES * math.log2(glob.radius) +
                                                      2 * math.log2(max_distance / (distance + max_distance)))

            # Parabolic function for amplitude
            amplitude = AMPLITUDE * (1 - 4 * (glob.z / DEPTH - 0.5) ** 2)

            # Multiply amplitude by the inverse of the frequency
            amplitude *= 1 / frequency

            if glob.vz > 0:
                if glob.z > DEPTH / 2:
                    doppler_shift = 1 + (speed_of_sound_in_water / 36) * (glob.vz / (DEPTH - glob.z))
                else:
                    doppler_shift = 1 - (speed_of_sound_in_water / 36) * (glob.vz / glob.z)
            else:
                if glob.z > DEPTH / 2:
                    doppler_shift = 1 - (speed_of_sound_in_water / 36) * (glob.vz / (DEPTH - glob.z))
                else:
                    doppler_shift = 1 + (speed_of_sound_in_water / 36) * (glob.vz / glob.z)

            amplitude *= doppler_shift

            # Generate triangle wave with the desired amplitude and Doppler shift
            triangle_wave = generate_triangle_wave(num_samples, frequency * doppler_shift, amplitude)
            signal += triangle_wave

    # Normalize the signal and convert to int8
    max_value = np.max(np.abs(next_signal))
    if max_value > 0:
        signal /= max_value
    else:
        signal = np.zeros((num_samples,), dtype=np.float32)

    # Multiply the signal by the volume shrink factor
    signal *= VOLUME_SHRINK_FACTOR

    fade_in_samples = round(SAMPLE_RATE * 1/8)  # ms fade in
    fade_out_samples = round(SAMPLE_RATE * 1/8)  # ms fade out
    signal = apply_fade(signal, fade_in_samples, fade_out_samples)

    signal_bytes = (signal * 127).astype(np.int8)

    # Ensure the buffer size is a multiple of bytes-per-sample and the number of channels
    buffer_size = len(signal_bytes)
    remainder = buffer_size % (NUM_CHANNELS * 1)  # 1 byte per sample for int8

    if remainder != 0:
        padding_size = NUM_CHANNELS * 1 - remainder
        signal_bytes = np.concatenate((signal_bytes, np.zeros(padding_size, dtype=np.int8)))

    return signal_bytes



def random_point_on_ellipsoid(a, b, c):
    while True:
        u = random.uniform(-1, 1)
        v = random.uniform(-1, 1)
        w = random.uniform(-1, 1)
        d = u**2/a**2 + v**2/b**2 + w**2/c**2

        if d <= 1:
            break

    x = (WIDTH / 2) + a * u
    y = (HEIGHT / 2) + b * v
    z = (DEPTH / 2) + c * w

    x = max(MIN_RADIUS, min(WIDTH - MIN_RADIUS, x))
    y = max(MIN_RADIUS, min(HEIGHT - MIN_RADIUS, y))
    z = max(MIN_RADIUS, min(DEPTH - MIN_RADIUS, z))

    return x, y, z

def color_difference(color1, color2):
    return sum(abs(color1[i] - color2[i]) for i in range(3))

def is_similar_color(color1, color2, threshold=32):
    return color_difference(color1, color2) < threshold

def calculate_mutation_range(globs):
    total_globs = len(globs)
    similar_color_count = 0

    for i in range(total_globs):
        for j in range(i+1, total_globs):
            if is_similar_color(globs[i].color, globs[j].color):
                similar_color_count += 1

    percentage_similar_color = similar_color_count / total_globs
    mutation_range = int(percentage_similar_color * 255)

    return mutation_range

def wild_color_mutation(parent_color, mutation_range):
    mutated_color = tuple(
        max(64, min(255, parent_color[i] + random.randint(-mutation_range, mutation_range)))
        for i in range(3)
    )
    return mutated_color

# Add a helper function to lerp between two values
def lerp(a, b, t):
    return a + (b - a) * t

class Glob:
    def __init__(self, x, y, z, radius, color, set_id=None, glob_sets=None):
        self.x = x
        self.y = y
        self.z = z
        self.radius = radius
        self.color = color
        self.glob_sets = glob_sets if glob_sets is not None else {}  # set default value
        self.creation_time = pygame.time.get_ticks()
        self.milestone1 = self.color
        self.milestone2 = self._get_next_milestone(self.color)
        self.lerp_t = 0
        self.lerp_speed = 0.0084

        if set_id is None:
            set_id = str(uuid.uuid4())

        self.set_id = set_id

        if self.set_id not in self.glob_sets:
            self.glob_sets[self.set_id] = set()
        self.glob_sets[self.set_id].add(self)

        speed_multiplier = 28.88 / self.radius
        self.vx = (random.uniform(-1, 1) / speed_multiplier) / SPEED_DIVISOR
        self.vy = (random.uniform(-1, 1) / speed_multiplier) / SPEED_DIVISOR
        self.vz = (random.uniform(-1, 1) / speed_multiplier) / SPEED_DIVISOR

        if self.radius == MAX_RADIUS:
            self.num_globs = len(INITIAL_GLOBS)
        else:
            self.num_globs = round(self.radius / (MAX_RADIUS / INITIAL_GLOBS))

        self.split_prob = SPLIT_PROB

    def _get_next_milestone(self, current_color):
        next_color = []
        for channel in current_color:
            min_val = max(0, channel - 128)
            max_val = min(255, channel + (255 - channel))
            next_channel = random.randint(min_val, max_val)
            next_color.append(next_channel)
        return tuple(next_color)

    def split(self, globs):
        if len(globs) < MAX_NUMBER_GLOBS and random.random() < self.split_prob:
            new_globs = []
            num_new_globs = random.randint(round(2*((self.radius/MAX_RADIUS*0.5)+1)), round(5*((self.radius/MAX_RADIUS*0.5)+1)))
            for _ in range(num_new_globs):
                new_x = self.x + random.uniform(-self.radius, self.radius)
                new_y = self.y + random.uniform(-self.radius, self.radius)
                new_z = self.z + random.uniform(-self.radius, self.radius)
                new_radius = self.radius / num_new_globs

                # Use wild color mutation for offspring
                mutation_range = calculate_mutation_range(globs)
                new_color = wild_color_mutation(self.color, mutation_range)

                new_glob = Glob(new_x, new_y, new_z, new_radius, new_color, self.set_id, self.glob_sets)
                new_glob.split_prob = self.split_prob
                new_globs.append(new_glob)
            return new_globs
        else:

            return None

    def draw(self, screen, bg_color):
        scale_factor = get_scale_factor(self.z, DEPTH)

        x = self.x * scale_factor + (1 - scale_factor) * (WIDTH / 2)
        y = self.y * scale_factor + (1 - scale_factor) * (HEIGHT / 2)
        scaled_radius = int(self.radius * scale_factor)

        r = int(self.color[0] * scale_factor + bg_color[0] * (1 - scale_factor))
        g = int(self.color[1] * scale_factor + bg_color[1] * (1 - scale_factor))
        b = int(self.color[2] * scale_factor + bg_color[2] * (1 - scale_factor))
        fade_color = (r, g, b)

        # Ensure fade_color is a valid RGB tuple
        fade_color = tuple(max(0, min(c, 255)) for c in fade_color)

        pygame.draw.circle(screen, fade_color, (int(x), int(y)), scaled_radius)

    def update(self, globs, glob_sets):
        global TRANSFER
        removed = False
        # Move glob according to its speed
        self.x += self.vx
        self.y += self.vy
        self.z += self.vz

        # Apply boundary conditions
        self.x %= WIDTH
        self.y %= HEIGHT
        self.z %= DEPTH

        # Update color according to the current milestones
        if self.lerp_t < 1:
            self.color = tuple(int(lerp(self.milestone1[i], self.milestone2[i], self.lerp_t)) for i in range(3))
            self.lerp_t += self.lerp_speed
        else:
            self.milestone1 = self.milestone2
            self.milestone2 = self._get_next_milestone(self.color)
            self.lerp_t = 0

        # Move globs out of sibling set if they are far enough apart
        siblings = [g for g in self.glob_sets[self.set_id] if g != self]
        for sibling in siblings:
            distance = math.sqrt((self.x - sibling.x)**2 + (self.y - sibling.y)**2 + (self.z - sibling.z)**2)
            if distance > 2 * self.radius:
                self.glob_sets[self.set_id].remove(self)
                new_set_id = str(uuid.uuid4())
                self.set_id = new_set_id
                self.glob_sets[new_set_id] = {self}
                break

        # Handle glob collision and color blending
        for other in globs:
            if other != self:
                distance = math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2 + (self.z - other.z)**2)
                if distance <= self.radius + other.radius:
                    if self.radius > other.radius:
                        larger, smaller = self, other
                    else:
                        larger, smaller = other, self

                    transfer_rate = TRANSFER  # Adjust this value to control the transfer rate
                    transferred_radius = smaller.radius * transfer_rate
                    larger.radius += transferred_radius
                    smaller.radius -= transferred_radius

                    # Color blending
                    larger_area = math.pi * larger.radius**2
                    smaller_area = math.pi * smaller.radius**2
                    total_area = larger_area + smaller_area
                    new_color = tuple(int((larger_area * larger.color[i] + smaller_area * smaller.color[i]) / total_area) for i in range(3))
                    larger.color = new_color

                    # Remove smaller glob if its radius becomes zero
                    if smaller.radius <= 0:
                        globs.remove(smaller)
                        if smaller.set_id in glob_sets and smaller in glob_sets[smaller.set_id]:
                            glob_sets[smaller.set_id].remove(smaller)
                            self.num_globs -= 1 # decrement the num_globs of the parent glob
                        removed = True
                        break

        # Check if the glob should split, outside the loop
        if self.radius > MAX_RADIUS:
            new_globs = self.split(globs)
            if new_globs:
                globs.extend(new_globs)
                if not removed and self in globs:
                    globs.remove(self)
                    self.num_globs -= 1 # decrement the num_globs of the parent glob

def attract_smaller_globs(globs, min_radius):
    force = 0.3/4.6
    for glob1 in globs:
        if glob1.radius < min_radius:
            nearest_larger_glob = None
            nearest_distance = float('inf')
            for glob2 in globs:
                if glob2.radius >= min_radius and glob2 != glob1:
                    distance = math.sqrt((glob1.x - glob2.x) ** 2 + (glob1.y - glob2.y) ** 2 + (glob1.z - glob2.z) ** 2)
                    if distance < nearest_distance:
                        nearest_larger_glob = glob2
                        nearest_distance = distance
            if nearest_larger_glob is not None:
                attraction_force = force * (min_radius / nearest_distance)
                dx = nearest_larger_glob.x - glob1.x
                dy = nearest_larger_glob.y - glob1.y
                dz = nearest_larger_glob.z - glob1.z
                norm = math.sqrt(dx**2 + dy**2 + dz**2)
                glob1.vx += dx / norm * attraction_force
                glob1.vy += dy / norm * attraction_force
                glob1.vz += dz / norm * attraction_force

def get_attraction_force(color1, color2):
    h1, s1, v1 = rgb_to_hsv(*(c / 255 for c in color1))
    h2, s2, v2 = rgb_to_hsv(*(c / 255 for c in color2))

    hue_diff = abs(h1 - h2)
    saturation_diff = abs(s1 - s2)

    attraction_strength = (1 - hue_diff) * (1 - saturation_diff)
    attraction_force = 0.0002 * attraction_strength

    return attraction_force

def get_scale_factor(z, depth):
    return 1 - (z / depth)

def average_glob_hsv(globs):
    if len(globs) == 0:
        return (0, 0, 0)  # default background color if there are no globs

    num_globs = len(globs)
    total_h, total_s, total_v = 0, 0, 0
    for glob in globs:
        h, s, v = rgb_to_hsv(*(c / 255 for c in glob.color))
        total_h += h
        total_s += s
        total_v += v

    avg_h = total_h / num_globs
    avg_s = total_s / num_globs
    avg_v = total_v / num_globs

    return avg_h, avg_s, avg_v

def get_random_color():
    r = random.randint(100, 255)
    g = random.randint(100, 255)
    b = random.randint(100, 255)
    return (r, g, b)

def main():
    global start
    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("Nia.S & ChatGPT's Lavalamp")
    clock = pygame.time.Clock()

    a, b, c = WIDTH / 2, HEIGHT / 2, DEPTH / 2

    globs = [Glob(*random_point_on_ellipsoid(a, b, c),
                  random.uniform(MIN_RADIUS, MAX_RADIUS),
                  get_random_color(),
                  str(uuid.uuid4())) for _ in range(INITIAL_GLOBS)]

    # Initialize the glob sets with the initial globs
    glob_sets = {i: {glob} for i, glob in enumerate(globs)}

    # Initialize audio mixer
    pygame.mixer.init(channels=NUM_CHANNELS + 1, buffer=AUDIO_BUFFER_SIZE)
    channel_group1 = pygame.mixer.Channel(0)
    channel_group2 = pygame.mixer.Channel(NUM_CHANNELS - 1)


    # Generate initial buffers for both intervals
    buffers1 = [generate_next_buffer(globs) for _ in range(3)]
    buffers2 = [generate_next_buffer(globs) for _ in range(3)]

    buffer_index1 = 0
    buffer_index2 = 0
    prev_buffer1 = buffers1[buffer_index1]
    prev_buffer2 = buffers2[buffer_index2]

    running = True
    while running:

        # Update background color
        try:
            avg_h, avg_s, avg_v = average_glob_hsv(globs)
            bg_color = tuple(int(c * 255) for c in hsv_to_rgb(1 - avg_h, 1 - avg_s, 1 - avg_v))
            screen.fill(bg_color)
            last_valid_bg_color = bg_color
        except ValueError:
            if last_valid_bg_color is not None:
                screen.fill(last_valid_bg_color)
            else:
                r, g, b = bg_color
                avg_value = (r + g + b) // 3
                default_color = (64, 64, 64) if avg_value >= 128 else (255, 255, 255)
                screen.fill(default_color)

        # Event handling
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                pygame.quit()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_f:
                    if screen.get_flags() & pygame.FULLSCREEN:
                        pygame.display.set_mode((WIDTH, HEIGHT))
                    else:
                        pygame.display.set_mode((WIDTH, HEIGHT), pygame.FULLSCREEN)

        new_globs = []

        # Sort globs based on z-axis
        sorted_globs = sorted(globs, key=lambda g: g.z, reverse=True)

        # Attract smaller globs to the nearest larger glob
        attract_smaller_globs(globs, MIN_RADIUS)

        # Draw globs in order of z-axis
        for glob in sorted_globs:
            result = glob.update(globs, glob_sets)
            if result:
                new_globs.extend(result)

            glob.draw(screen, bg_color)

        # Update and play audio buffers for both intervals
        prev_buffer1 = play_buffer(channel_group1, buffers1[buffer_index1], prev_buffer1)
        buffer_index1 = (buffer_index1 + 1) % 3
        buffers1[buffer_index1] = generate_next_buffer(globs)

        prev_buffer2 = play_buffer(channel_group2, buffers2[buffer_index2], prev_buffer2)
        buffer_index2 = (buffer_index2 + 1) % 3
        buffers2[buffer_index2] = generate_next_buffer(globs)

        # Update the display and tick the clock
        pygame.display.flip()
        clock.tick(FPS)

        # Add new globs to the list
        globs.extend(new_globs)

        # Remove globs that have radius less than 1
        globs = [glob for glob in globs if glob.radius >= 1]

        # Update the num_globs attribute of all globs
        num_globs = len(globs)
        for glob in globs:
            glob.num_globs = num_globs

    pygame.quit()

if __name__ == "__main__":
    main()

